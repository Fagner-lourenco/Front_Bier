"""
Token Validator for EDGE Server
HMAC validation with expiry check and single-use enforcement
"""
import hmac
import hashlib
import time
import json
import base64
from typing import Optional, Tuple, Dict, Any
from dataclasses import dataclass
from threading import Lock

from config import config


@dataclass
class TokenPayload:
    """Validated token payload"""
    sale_id: str
    beverage_id: str
    volume_ml: int
    tap_id: int
    timestamp: float
    nonce: str
    token_raw: str = ""  # Token original para rastreabilidade
    
    def is_expired(self, tolerance_seconds: int = 30) -> bool:
        """Check if token has expired"""
        return time.time() > (self.timestamp + tolerance_seconds)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "sale_id": self.sale_id,
            "beverage_id": self.beverage_id,
            "volume_ml": self.volume_ml,
            "tap_id": self.tap_id,
            "timestamp": self.timestamp,
            "nonce": self.nonce,
            "token_raw": self.token_raw
        }


class TokenValidator:
    """
    Validates dispense authorization tokens using HMAC-SHA256
    
    Token format: base64(json_payload).base64(hmac_signature)
    
    Payload structure:
    {
        "sale_id": "uuid",
        "beverage_id": "uuid",
        "volume_ml": 500,
        "tap_id": 1,
        "timestamp": 1703347200.123,
        "nonce": "random_string"
    }
    """
    
    def __init__(self, hmac_secret: str = None):
        self.hmac_secret = (hmac_secret or config.security.HMAC_SECRET).encode('utf-8')
        self.used_tokens: Dict[str, float] = {}  # nonce -> expiry_time
        self._lock = Lock()
        
    def _compute_hmac(self, payload_bytes: bytes) -> str:
        """Compute HMAC-SHA256 signature"""
        signature = hmac.new(
            self.hmac_secret,
            payload_bytes,
            hashlib.sha256
        ).digest()
        return base64.urlsafe_b64encode(signature).decode('utf-8')
    
    def generate_token(self, 
                       sale_id: str,
                       beverage_id: str,
                       volume_ml: int,
                       tap_id: int,
                       nonce: str = None) -> str:
        """
        Generate a signed dispense token (for testing purposes)
        In production, tokens are generated by SaaS backend
        """
        import secrets
        
        payload = {
            "sale_id": sale_id,
            "beverage_id": beverage_id,
            "volume_ml": volume_ml,
            "tap_id": tap_id,
            "timestamp": time.time(),
            "nonce": nonce or secrets.token_urlsafe(16)
        }
        
        payload_json = json.dumps(payload, separators=(',', ':'))
        payload_b64 = base64.urlsafe_b64encode(payload_json.encode('utf-8')).decode('utf-8')
        signature = self._compute_hmac(payload_json.encode('utf-8'))
        
        return f"{payload_b64}.{signature}"
    
    def validate_token(self, token: str) -> Tuple[bool, Optional[TokenPayload], Optional[str]]:
        """
        Validate a dispense token
        
        Returns:
            Tuple of (is_valid, payload, error_message)
        """
        # Clean expired tokens periodically
        self._cleanup_used_tokens()
        
        # Parse token format
        try:
            parts = token.split('.')
            if len(parts) != 2:
                return False, None, "Invalid token format"
            
            payload_b64, signature_received = parts
        except Exception:
            return False, None, "Token parsing failed"
        
        # Decode payload
        try:
            # Adiciona padding se necessÃ¡rio (JavaScript remove o padding)
            payload_b64_padded = payload_b64 + '=' * (-len(payload_b64) % 4)
            payload_json = base64.urlsafe_b64decode(payload_b64_padded).decode('utf-8')
            payload_dict = json.loads(payload_json)
        except Exception as e:
            return False, None, f"Payload decode failed: {str(e)}"
        
        # Verify HMAC signature
        # O Python gera base64 com padding, mas JS remove padding
        # Compara removendo padding de ambos para compatibilidade
        expected_signature = self._compute_hmac(payload_json.encode('utf-8'))
        # Remove padding for comparison (JS uses no padding)
        signature_received_clean = signature_received.rstrip('=')
        expected_signature_clean = expected_signature.rstrip('=')
        if not hmac.compare_digest(signature_received_clean, expected_signature_clean):
            return False, None, "Invalid signature"
        
        # Parse payload fields
        try:
            payload = TokenPayload(
                sale_id=payload_dict['sale_id'],
                beverage_id=payload_dict['beverage_id'],
                volume_ml=int(payload_dict['volume_ml']),
                tap_id=int(payload_dict['tap_id']),
                timestamp=float(payload_dict['timestamp']),
                nonce=payload_dict['nonce'],
                token_raw=token  # Armazena token original para rastreabilidade
            )
        except KeyError as e:
            return False, None, f"Missing field: {e}"
        except (ValueError, TypeError) as e:
            return False, None, f"Invalid field value: {e}"
        
        # Check expiry
        if payload.is_expired(config.security.TOKEN_EXPIRY_TOLERANCE):
            return False, None, "Token expired"
        
        # Check single-use (if enabled)
        if config.security.SINGLE_USE_TOKENS:
            with self._lock:
                if payload.nonce in self.used_tokens:
                    return False, None, "Token already used"
                
                # Mark token as used
                expiry_time = time.time() + config.security.USED_TOKENS_TTL
                self.used_tokens[payload.nonce] = expiry_time
        
        return True, payload, None
    
    def _cleanup_used_tokens(self):
        """Remove expired entries from used tokens cache"""
        with self._lock:
            current_time = time.time()
            expired = [nonce for nonce, expiry in self.used_tokens.items() 
                      if current_time > expiry]
            for nonce in expired:
                del self.used_tokens[nonce]
    
    def mark_token_unused(self, nonce: str):
        """
        Remove token from used list (for rollback on dispense failure)
        """
        with self._lock:
            self.used_tokens.pop(nonce, None)


# Global validator instance
token_validator = TokenValidator()


# Example usage and testing
if __name__ == "__main__":
    validator = TokenValidator()
    
    # Generate test token
    test_token = validator.generate_token(
        sale_id="test-sale-123",
        beverage_id="550e8400-e29b-41d4-a716-446655440001",
        volume_ml=500,
        tap_id=1
    )
    print(f"Generated token: {test_token}")
    
    # Validate token
    is_valid, payload, error = validator.validate_token(test_token)
    print(f"Valid: {is_valid}")
    if payload:
        print(f"Payload: {payload.to_dict()}")
    if error:
        print(f"Error: {error}")
    
    # Try to reuse (should fail)
    is_valid2, _, error2 = validator.validate_token(test_token)
    print(f"Reuse attempt - Valid: {is_valid2}, Error: {error2}")
